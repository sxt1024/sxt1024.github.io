1.8 自己编写磁盘镜像工具


## 软件列表

winimage

## 1 磁盘镜像格式


* Dsk格式映像

Dsk格式是通用通用磁盘映像，一般做硬盘映像使用，打开dsk格式文件可以使用WinImage等软件，加载和修改可以使用Imdisk命令，使用Grub4Dos还可以直接挂载dsk格式映像为虚拟硬盘启动。另外，Apple II模拟器及一些电脑游戏映像一般也倾向使用这个格式。

* Img格式映像

IMG是比较常见的映像格式，如果是CD或DVD光盘映像，格式与ISO完全相同，可以直接改扩展名为ISO使用，如果是作为软盘或硬盘映像使用时，打开和编辑可以使用UltraISO、WinImage，使用可以借助daemon或Alcohol 120%加载。

* Ima格式映像

IMA也是一种映像格式，本来只是用于软盘映像，IMA格式文件只是把磁盘内容简单的DUMP出来，包含内容与IMG格式相同，打开和编辑可以使用UltraISO、WinImage，使用上也被微软虚拟机所支持，也可以借助daemon或Alcohol 120%加载。

* Vhd格式映像

VHD全称Virtual Hard Disks，虚拟磁盘的意思，可以同时支持在Windows平台和Linux平台使用，最初由Connectix创建，后来被微软虚拟机采纳使用， 完全采用软件模拟真实磁盘的柱面、扇区和磁头关系，虚拟机也大都使用这个格式，Disk2vhd、Winmount等都是很常用的加载或转换工具。



1)磁盘镜像格式
我们首先用winimage建立一个1.44M的软盘镜像os.img，然后引入引导文件boot.bin。使用二进制方式打开os.img和boot.bin。可以发现磁盘镜像格式如下：


* os.img除了开始的一段位置外，其他的都是数据0

* 通过比较os.img和boot.bin，发现os.img的开始位置就是boot.bin。也就是说os.img的最开始的512个字节就是引导扇区的内容。

2）创建磁盘镜像

windows下可以使用用dos的命令： fsutil file createnew Rats.ima 1474560 创建一个1.44M的镜像

windows下可以使用winimage工具创建一个1.44M的镜像

使用qemu命令创建：qemu-img create - -o size=1440k Rats.ima


## 2 go语言编写磁盘镜像工具

或许你会觉得用上面的工具来创建镜像有点复杂,不够happy.因此我们就自己定制一个镜像工具好了.

首先你要了解生成的镜像文件的结构,其实是一个.iso文件,文件最开始的位置为512kb的引导文件,其它位置存储的都是0.

接下来，我使用go写了一个磁盘镜像工具(当然啦,用其它什么语言都能实现,看你的心情)，创建镜像并引入引导文件。

定义命令格式如下：

> makeima os.img -size=1474560 -b=boot.bin

参数说明：
1）size参数：文件大小。可使用k,M后缀
2）-b设置引导扇区文件

go语言代码

	package main

	import (
		"flag"
		"fmt"
		"os"
		"strconv"
		"strings"
	)

	/*
	 * 参数格式 makeima -size=1440k -b=boot.bin os.img
	 */
	func main() {

		size_flag := flag.String("size", "1440k", "文件大小")
		bootname_flag := flag.String("b", "", "引导文件名")
		flag.Parse()


		//解析镜像文件名
		if len(flag.Args()) < 1 {
			fmt.Println("请输入镜像文件名")
			fmt.println(`参数格式 makeima -size=1440k -b=boot.bin os.img`)
			return
		}

		//需要parse之后再获取值
		size := *size_flag
		bootname := *bootname_flag

		//解析size
		size_t := 0
		realSize := 1
		if len(size) > 0 {
			unit := size[len(size)-1]
			switch unit {
			case 'k':
				size = strings.TrimRight(size, "k")
				realSize = 1024
			case 'K':
				size = strings.TrimRight(size, "K")
				realSize = 1024
			case 'm':
				size = strings.TrimRight(size, "m")
				realSize = 1024 * 1000
			case 'M':
				size = strings.TrimRight(size, "M")
				realSize = 1024 * 1000
			}

		}
		size_t, err := strconv.Atoi(size)
		if err != nil {
			fmt.Println("错误的镜像大小格式", err)
			return
		}
		realSize *= size_t

		//解析引导文件
		hasboot := true
		bc := make([]byte, 512)
		if bootname != "" {
			fi, err := os.Open(bootname)
			if err != nil {
				fmt.Println("引导文件读取错误:", bootname, err)
				return
			}
			fi.Read(bc)
			if len(bc) != 512 {
				fmt.Println("引导文件大小错误")
				return
			}

		} else {
			hasboot = false
		}


		imaname := flag.Args()[0]
		if imaname == "" {
			fmt.Println("请输入镜像文件名")
		}
		fi, err := os.Create(imaname)
		if err != nil {
			fmt.Println("磁盘映像创建错误:", imaname, err)
			return
		}
		//创建镜像文件
		fmt.Println("正在创建磁盘镜像......")
		if hasboot {
			fi.Write(bc)
			fi.Write(make([]byte, realSize-512))
			fmt.Println("正在写入引导文件...")
		} else {
			fi.Write(make([]byte, realSize))
		}
		fmt.Printf("创建磁盘镜像完成,大小为%d字节\n", realSize)
		fi.Close()
	}


好了，通过makeima Rats.img -b=boot.bin	我们可以创建一个1.44M的带引导扇区的软盘镜像。至于往写入文件，我们就直接使用winimage的命令行操作了：
winimage.exe Rats.IMA  /I loader.sys /h

## 编写makefile
下面创建一个makefile文件，将所有的编译，连接，创建镜像，添加文件，运行虚拟器等等，进行一键执行。
代码如下：

	# 配置
	export path=$path;D:\MinGW\bin;
	boot = boot
	nasm = tools/nasm.exe
	gcc = D:/mingw/bin/gcc.exe
	obj2bim = tools/obj2bim.exe
	bim2hrb = tools/bim2hrb.exe
	winima = winima90/winimage.exe
	mkima = tools/mkima.exe

	build: Rats.IMA
	##copy Rats.IMA ..\Qemu-windows-1.0.1  /y
		..\Qemu-windows-1.0.1\qemu-system-i386.exe -fda Rats.ima

	Rats.IMA:boot.bin loader.sys
		$(mkima) -b=boot.bin Rats.IMA
		$(winima) Rats.IMA  /I loader.sys /h

	loader.sys :  boot.bin loader0.bin loader.hrb
	#确保PATH环境下没有sh.exe
		copy /B loader0.bin+loader.hrb loader.sys

	# 构建bin
	%.bin: $(boot)/%.asm
		$(nasm) -f bin -o $*.bin $(boot)/$*.asm

	# 构建hrb
	loader.hrb : loader.bim
		$(bim2hrb) loader.bim loader.hrb 0

	# 构建bim
	loader.bim : loader.obj loaderfunc.obj
		$(obj2bim) @haribote/haribote.rul out:loader.bim stack:3136k map:loader.map \
			loader.obj loaderfunc.obj

	# 构建obj
	loader.obj: $(boot)/loader.c
		$(gcc)  -c  $(boot)/loader.c -o loader.obj

	loaderfunc.obj:$(boot)/loaderfunc.asm
		$(nasm) -f win32 -o loaderfunc.obj $(boot)/loaderfunc.asm

	# clean
	clean:
		-del *.bin
		-del *.bim
		-del *.map
		-del *.lst
		-del *.gas
		-del *.obj
		-del *.sys
		-del loader.hrb
