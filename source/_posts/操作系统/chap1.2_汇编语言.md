---
title: "1.2_汇编语言"
date: 2018-10-04
timezone: UTC+8
tags: ["操作系统"]
categories: ["操作系统"]
---



## 汇编语言

### 1. 机器语言与汇编语言

**1.1 机器语言简介**
对于计算机来说，能识别的只有0,1两个数字。最早的时候，程序员就是用0，1这2个符号来进行编码，不如远古时期的纸带卡片，使用打孔来代表1，不打孔代表0，然后通过纸带机或卡片机来识别运行这种0，1程序。

这种程序方便计算机运行，但是却是不容易让程序员进行编写的。

**1.2 汇编语言简介**

人们通过编写汇编指令，然后使用汇编编译器编译成机器语言。汇编语言比机器语言更容易阅读识别

比如

操作：寄存器BX的内容送到AX中

```assembly
1000100111011000              // 机器指令
mov ax,bx                    // 汇编指令
```



### 2. 指令执行



**2.1 指令寻址**

> cs寄存器，ip寄存器

每次从  [cs，ip] 取一条指令执行，执行后ip值增加，指向下一条指令

CPU执行时，会一直的从内存单元中读取指令，坊到指令缓冲器执行。而取指令时，是根据CS寄存器和IP寄存器来获取一个地址
[CS:IP]。这个地址指向内存单元中的代码段。CPU从中读取一条指令执行，然后IP指向下一条指令，继续读取执行。如此循环。
[CS+IP]：CS=段地址,IP=偏移地址。CPU一直从[CS+IP]指向的内存单元处读取指令。

**2.2 访问数据**
当CPU需要获取一个数据时，这时候代码段中能够获得的是DS寄存器和一个偏移地址。
`[DS*0x10 + 偏移地址]`，指定地址时候可以不显示的写出DS。
这个地址指向内存单元中的数据。CPU根据这个地址获取到需要的数据。
基本地址：DS存储的是基本地址，但是在程序中段寄存器DS一般可以不显示说明。只用 `[偏移地址]` 来表示内存单元的地址。
偏移地址：是一个常数，可以直接使用数字来表示，比如：`[553]`。也可以使用BX，BP，SI，DI（其他的寄存器不能表示内存地址）中的值来表示。比如`[BX]`。
`[DS+BX]：DS=段地址,BX=偏移地址`，内存单元地址为`DS*0x10+BX`。计算其寻址能力根据可指定的内存范围大概为0-1M之间。

**2.3 指令跳转**

当CPU执行完一块内存中的代码段时，使用JMP命令来修改CS寄存器和IP寄存器的值。从而控制计算机指令执行的跳转。

jmp：jmp指令转移就是修改cs，ip寄存器的指向。来完成跳转的功能。JMP导致[CS:IP]指向新的内存单元，CPU从新的内存单元读取指令。







### 1. 赋值操作

- mov 

> mov ax, 0x1

1）将值赋给寄存器：mov 寄存器,寄存器|内存单元|立即数

```assembly
mov ax,0x0018H  		;ax = 0x0018H
mov ax,[0x0c200H] 	;ax = [ds:0x0c200H]
mov ax,bx  	 	  		;ax = bx
```

1）将值赋给内存单元：mov 内存单元,寄存器|内存单元|立即数

```assembly
mov [0x0a200H],0x0018H   	;ax = 0x0018H
mov [0x0a200H],[0x0c200H] 	;ax = [ds:0x0c200H]
mov [0x0a200H],bx   	  		;ax = bx
```



### 2. 算术操作

下面是算术操作指令的简单列表：

- add —— 整数加

  sub —— 减法: 

  mul —— 无符号乘法(无符号):	

- IMUL —— 有符号乘

- DIV —— 无符号除

  div 寄存器|内存单元(除数).

- IDIV —— 有符号除

- INC —— 自增

- DEC —— 自减

- NEG —— 取反

- CMP —— 比较大小



### 3. 转移操作

- JE —— 如果相等则跳转
- JNE —— 如果不相等则跳转
- JZ —— 如果为 0 则跳转
- JNZ —— 如果不为 0 则跳转
- JC—— 如果进位 则跳转
- JNC—— 如果不进位 则跳转
- JG —— 如果第一个操作数比第二个大则跳转
- JGE —— 如果第一个操作数比第二个大或者相等则跳转
- JA —— 与 JG 指令相同，只不过比较的是无符号数则跳转
- JAE —— 与 JGE 指令相同，只不过比较的是无符号数则跳转

- JO—— 如果溢出则跳转
- JNO—— 如果不进位则跳转
- 

### 4. 跳转指令

**jmp指令**

> cs寄存器，ip寄存器

通过修改 [cs，ip] 内容，达到跳转效果。

- jmp near 短转移 ： [ ip <- new ip val]
- jmp far 远转移 ： [ cs<- new cs val, ip <- new ip val]
- jmp word 段间转移，可从32位跳转64位指令



**call指令**

> cs寄存器，ip寄存器，栈寄存器

1）压栈当前指令位置   [ss, sp] <-  [cs, ip] 

2)  跳转到函数执行

3）返回，出栈当前指令位置   [cs, ip] <-   [ss, sp]

4）继续执行指令

- call
- call far
- call world



**ret指令**

> cs寄存器，ip寄存器，栈寄存器

3）返回，出栈当前指令位置   [cs, ip] <-   [ss, sp]

4）继续执行指令



**loop指令**

> cx寄存器

判断 [cs] 寄存器值是否为0，为0停止循环，不为0继续循环。

每次执行  [cs=cx-1]



### 5. 栈操作

- push：入栈，将寄存器的数据入栈

- pop： 栈，数据存储到寄存器中

  栈寄存器

  首先CPU进行出栈入栈操作时，需要先分配一段栈空间的内存，来存储数据使用。

  这段内存的位置由栈段寄存器SS和栈指针寄存器SP来指定。

  ```
    栈顶地址 = 栈段寄存器SS << 4 + 栈指针寄存器SP
  ```

   每次进行出栈入栈操作时，SS和SP会更新得到新的栈顶位置。

   我们可以通过指定	栈段寄存器SS和栈指针寄存器SP的值来初始化栈空间分配。









## 栈操作

栈顶元素： [ss:sp]    (默认 [ss:0xf] )

栈空间  ：  [ss:0] -> [ss:0xf]



**push指令**

> ss寄存器，sp寄存器

通过修改 [ss，sp] 内容，改变栈顶位置

[cs, sp] <- 栈顶位置

执行后, 栈值增加，指向新的地址

[cs,sp+2] <- 栈顶位置



**pop指令**

> ss寄存器，sp寄存器

通过修改 [ss，sp] 内容，改变栈顶位置

执行后, 栈值减少，指向上一个地址

[cs,sp-2] <- 栈顶位置



### 其他指令

CLI ： Clear Interupt

STI ：Set Interupt

CLD ： Clear Director

STD ：Set Director

REP：

Loop：



# CPU指令

## 赋值

1）将值赋给寄存器：mov 寄存器,寄存器|内存单元|立即数

	mov ax,0x0018H  		;ax = 0x0018H
	mov ax,[0x0c200H] 	;ax = [ds:0x0c200H]
	mov ax,bx  	 	  		;ax = bx

1）将值赋给内存单元：mov 内存单元,寄存器|内存单元|立即数

	mov [0x0a200H],0x0018H   	;ax = 0x0018H
	mov [0x0a200H],[0x0c200H] 	;ax = [ds:0x0c200H]
	mov [0x0a200H],bx   	  		;ax = bx

## 运算

1）加法: add 寄存器,寄存器|立即数

	add ax,0x0017H 	;ax=ax+0x0017H
	add ax,bx			;ax=ax+bx

2. 减法: sub 寄存器,寄存器|立即数

   sub ax,0x0017H 	;ax=ax-0x0017H
   sub ax,bx			;ax=ax-bx

3. 乘法(无符号):	mul 寄存器.

使用寄存器: AX存放目标操作数，操作后AX和DX存放结果。

		mov eax 0x0100H
		mul 寄存器

4) 除法:	div 寄存器|内存单元(除数).

使用寄存器: AX和DX存放被除数，操作后AX和DX存放商和余数。
​		div 寄存器|内存单元

5. 自增1:inc 寄存器

   inc ax

6. 自减1:dec 寄存器

   dec ax

 7）取补码：nec

## 栈寄存器

首先CPU进行出栈入栈操作时，需要先分配一段栈空间的内存，来存储数据使用。

这段内存的位置由栈段寄存器SS和栈指针寄存器SP来指定。

	栈顶地址 = 栈段寄存器SS << 4 + 栈指针寄存器SP

每次进行出栈入栈操作时，SS和SP会更新得到新的栈顶位置。

我们可以通过指定	栈段寄存器SS和栈指针寄存器SP的值来初始化栈空间分配。

## 栈操作

栈的操作主要有2个:

1. 入栈 push

push 寄存器

将寄存器的数据入栈

2. 出栈 pop

pop 寄存器

出栈，数据存储到寄存器中
