---
title: chap1.2_汇编语言
date: 2018-10-04
timezone: UTC+8
tags:
  - 操作系统
categories: 操作系统
---

### 1 机器语言与汇编语言

**1.2 汇编语言简介**

人们通过编写汇编指令，然后使用汇编编译器编译成机器语言。汇编语言比只有0和
1组成的机器语言更容易阅读识别

比如

操作：寄存器BX的内容送到AX中

```assembly
1000100111011000              // 机器指令
mov ax,bx                    // 汇编指令
```


### 2. 指令执行

**2.1 指令寻址**

> cs寄存器，ip寄存器

每次从  [cs，ip] 指向的内存位置取一条指令执行，执行后ip值增加，指向下一条指令的内存位置

CPU执行时，会一直的从内存单元中读取指令，坊到指令缓冲器执行。而取指令时，是根据CS寄存器和IP寄存器来获取一个地址
[CS:IP]。这个地址指向内存单元中的代码段。CPU从中读取一条指令执行，然后IP指向下一条指令，继续读取执行。如此循环。
[CS+IP]：CS=段地址,IP=偏移地址。CPU一直从[CS+IP]指向的内存单元处读取指令。

**2.2 访问数据**
当CPU需要获取一个数据时，这时候代码段中能够获得的是DS寄存器和一个偏移地址。
`[DS*0x10 + 偏移地址]`，指定地址时候可以不显示的写出DS。
这个地址指向内存单元中的数据。CPU根据这个地址获取到需要的数据。
基本地址：DS存储的是基本地址，但是在程序中段寄存器DS一般可以不显示说明。只用 `[偏移地址]` 来表示内存单元的地址。
偏移地址：是一个常数，可以直接使用数字来表示，比如：`[553]`。也可以使用BX，BP，SI，DI（其他的寄存器不能表示内存地址）中的值来表示。比如`[BX]`。
`[DS+BX]：DS=段地址,BX=偏移地址`，内存单元地址为`DS*0x10+BX`。计算其寻址能力根据可指定的内存范围大概为0-1M之间。

**2.3 指令跳转**

当CPU执行完一块内存中的代码段时，使用JMP命令来修改CS寄存器和IP寄存器的值。从而控制计算机指令执行的跳转。

jmp：jmp指令转移就是修改cs，ip寄存器的指向。来完成跳转的功能。JMP导致[CS:IP]指向新的内存单元，CPU从新的内存单元读取指令。


### 1. 赋值操作

- mov 

> mov ax, 0x1

1）将值赋给寄存器：mov 寄存器,寄存器|内存单元|立即数

```assembly
mov ax,0x0018H  		;ax = 0x0018H
mov ax,[0x0c200H] 	;ax = [ds:0x0c200H]
mov ax,bx  	 	  		;ax = bx
```

1）将值赋给内存单元：mov 内存单元,寄存器|内存单元|立即数

```assembly
mov [0x0a200H],0x0018H   	;ax = 0x0018H
mov [0x0a200H],[0x0c200H] 	;ax = [ds:0x0c200H]
mov [0x0a200H],bx   	  	;ax = bx
```



### 2. 算术操作

下面是算术操作指令的简单列表：

- add —— 整数加

  sub —— 减法: 

  mul —— 无符号乘法(无符号):	

- IMUL —— 有符号乘

- DIV —— 无符号除

  div 寄存器|内存单元(除数).

- IDIV —— 有符号除

- INC —— 自增

- DEC —— 自减

- NEG —— 取反

- CMP —— 比较大小



### 3. 转移操作

- JE —— 如果相等则跳转
- JNE —— 如果不相等则跳转
- JZ —— 如果为 0 则跳转
- JNZ —— 如果不为 0 则跳转
- JC—— 如果进位 则跳转
- JNC—— 如果不进位 则跳转
- JG —— 如果第一个操作数比第二个大则跳转
- JGE —— 如果第一个操作数比第二个大或者相等则跳转
- JA —— 与 JG 指令相同，只不过比较的是无符号数则跳转
- JAE —— 与 JGE 指令相同，只不过比较的是无符号数则跳转

- JO—— 如果溢出则跳转
- JNO—— 如果不进位则跳转
- 

### 4. 跳转指令

**jmp指令**

> cs寄存器，ip寄存器

通过修改 [cs，ip] 内容，达到跳转效果。

- jmp near 短转移 ： [ ip <- new ip val]
- jmp far 远转移 ： [ cs<- new cs val, ip <- new ip val]
- jmp word 段间转移，可从32位跳转64位指令



**call指令**

> cs寄存器，ip寄存器，栈寄存器

1）压栈当前指令位置   [ss, sp] <-  [cs, ip] 

2)  跳转到函数执行

3）返回，出栈当前指令位置   [cs, ip] <-   [ss, sp]

4）继续执行指令

- call
- call far
- call world



**ret指令**

> cs寄存器，ip寄存器，栈寄存器

3）返回，出栈当前指令位置   [cs, ip] <-   [ss, sp]

4）继续执行指令



**loop指令**

> cx寄存器

判断 [cs] 寄存器值是否为0，为0停止循环，不为0继续循环。

每次执行  [cs=cx-1]



### 5. 栈操作

- push：入栈，将寄存器的数据入栈

- pop： 栈，数据存储到寄存器中

  栈寄存器

  首先CPU进行出栈入栈操作时，需要先分配一段栈空间的内存，来存储数据使用。

  这段内存的位置由栈段寄存器SS和栈指针寄存器SP来指定。

  ```
    栈顶地址 = 栈段寄存器SS << 4 + 栈指针寄存器SP
  ```

   每次进行出栈入栈操作时，SS和SP会更新得到新的栈顶位置。

   我们可以通过指定	栈段寄存器SS和栈指针寄存器SP的值来初始化栈空间分配。



## 栈操作

栈顶元素： [ss:sp]    (默认 [ss:0xf] )

栈空间  ：  [ss:0] -> [ss:0xf]



**push指令**

> ss寄存器，sp寄存器

通过修改 [ss，sp] 内容，改变栈顶位置

[cs, sp] <- 栈顶位置

执行后, 栈值增加，指向新的地址

[cs,sp+2] <- 栈顶位置



**pop指令**

> ss寄存器，sp寄存器

通过修改 [ss，sp] 内容，改变栈顶位置

执行后, 栈值减少，指向上一个地址

[cs,sp-2] <- 栈顶位置



### 其他指令

CLI ： Clear Interupt

STI ：Set Interupt

CLD ： Clear Director

STD ：Set Director

REP：

Loop：



# CPU指令

## 赋值

1）将值赋给寄存器：mov 寄存器,寄存器|内存单元|立即数

	mov ax,0x0018H  		;ax = 0x0018H
	mov ax,[0x0c200H] 	;ax = [ds:0x0c200H]
	mov ax,bx  	 	  		;ax = bx

1）将值赋给内存单元：mov 内存单元,寄存器|内存单元|立即数

	mov [0x0a200H],0x0018H   	;ax = 0x0018H
	mov [0x0a200H],[0x0c200H] 	;ax = [ds:0x0c200H]
	mov [0x0a200H],bx   	  		;ax = bx

## 运算

1）加法: add 寄存器,寄存器|立即数

	add ax,0x0017H 	;ax=ax+0x0017H
	add ax,bx			;ax=ax+bx

2. 减法: sub 寄存器,寄存器|立即数

   sub ax,0x0017H 	;ax=ax-0x0017H
   sub ax,bx			;ax=ax-bx

3. 乘法(无符号):	mul 寄存器.

使用寄存器: AX存放目标操作数，操作后AX和DX存放结果。

		mov eax 0x0100H
		mul 寄存器

4) 除法:	div 寄存器|内存单元(除数).

使用寄存器: AX和DX存放被除数，操作后AX和DX存放商和余数。
​		div 寄存器|内存单元

5. 自增1:inc 寄存器

   inc ax

6. 自减1:dec 寄存器

   dec ax

 7）取补码：nec

## 栈寄存器

首先CPU进行出栈入栈操作时，需要先分配一段栈空间的内存，来存储数据使用。

这段内存的位置由栈段寄存器SS和栈指针寄存器SP来指定。

	栈顶地址 = 栈段寄存器SS << 4 + 栈指针寄存器SP

每次进行出栈入栈操作时，SS和SP会更新得到新的栈顶位置。

我们可以通过指定	栈段寄存器SS和栈指针寄存器SP的值来初始化栈空间分配。

## 栈操作

栈的操作主要有2个:

1. 入栈 push

push 寄存器

将寄存器的数据入栈

2. 出栈 pop

pop 寄存器

出栈，数据存储到寄存器中




汇编编译器

[TOC]

### 常见的汇编编译器

汇编语言目前主要有2种风格式

1. intel风格：intel风格
2. AT&T风格：多数在linux系统上使用。

汇编编译器有以下几种

1. gas编译器: 与gcc搭配食用，不用详细说了。
2. nasm: 目前编写比较优雅的一个。
3. masm:微软开发的编译器，可以忽略掉。2333~~



### Nasm汇编编译器
**安装nasm编译器**

ubuntu下使用命令安装

> sudo apt-get install nasm

### 指令长度

| 名称  | 长度  | 说明 |
| ----- | ----- | ---- |
| byte  | 8 位  | 字节 |
| word  | 16 位 | 词   |
| dword | 32 位 | 双词 |
### 伪指令

**什么是伪指令**



**内存单元表示：[]**

任何被[]包含的变量都是地址。[]表示一个内存单元。内存单元的段地址为ds中的存储数据，偏移地址为[]里面表示的数据。

例如：

```
mov [gs,0x10]   0x3F
```



**注释: `;`**

例如

```
mov ax,0x02    ;ax=0x02
```



**db,dw,dd**



**当前指令开始地址：$	**	
被称为当前位置计数器

在汇编程序对源程序进行汇编的过程中，使用地址计数器来保证当前正在汇编的指令地址。地址计数器值可用“$”来表示，汇编语言也允许用户直接用“$”来引用地址计数器的当前值，因此，ORG $＋5可表示从当前地址开始跳过5个字节存储单元，在指令和伪指令中，也可直接用“$”表示地址计数器的当前值。

故jmp $进入了一个无限循环。



**当前段开始地址：$$	**


**写字节：`DB，DW，DD`**	
说明：

- DB：写出一个字节（BYTE）。会按照字节输出
- DW ：输出一个字(WORD=2BYTE).也就是输出2个字节(16位)。
- DD ：输出两个字(DoubleWord=4BYTE).也就是输出4个字节(32位)



**填充：RESB**

说明：

RESB 510-($-$$)    意思即是510字节位置（0x1fe） 减去这一行现在的字节位置:132。这些都填入0x00

$表示当前行被汇编后的地址，也就是当前行的地址。$$代表一个section节的开始地址。也就是这个section的开始地址。

也可以使用times 510-($-$$)  db  0来表示上面的意思。




**重复指令或数据：times**

说明：

重复指令或数据

> 例如：
>
> times 510-($-$$)  db  0
>
>  times前缀引起指令被汇编多次。其中$$表示是该程序的初始代码段的地址，故该指令将会被执行510-($-$$)次。也就是用0来填充剩下的空间，达到510字节。



**org**



## 数据类型

1. 数据类型,基本的数据类型如下

   byte : byte          字节,8位
   word : word          字，16位
   dword : double word  双字,32位
   qword : quadword     四字,64位

2. 初始化常量值
   db	:	define byte 	字节,8位
   dw :  define word 	字，16位
   dd :	define doubleworld 双字,32位
   dq :  define quadword    四字,64位
   ​

   . 非初始化数据	

   resb ：reserve byte
   resw ：reserve word
   resd ：reserve doubword
   resq ：reserve quadword
   ​

## 汇编编译器NASM

### 1 nasm命令用法：

```
> nasm.exe -f {formart} -o 生成文件 源文件
```

可以使用查看支持生成的文件的{formart}

### 2 NASM分段

段（Section）： 每个汇编程序都是由段来组成的，有以下的段：

1. data:用来声明初始化的数据或常量
2. bss:用来声明未初始化的变量
3. text:用来存放代码

### 3 NASM的伪指令:

伪指令属于编译器自定义的特殊指令，在编译过程中由编译器进行处理转换。

1. org

   > 格式：ORG 偏移地址

   例如：org 07c00h

   ORG伪指令用来指出其后的程序段或数据块存放的起始地址的偏移量。汇编程序汇编时把语句中表达式的值作为起始地址，连续存放ORG语句之后的程序和数据，直到出现一个新的ORG指令。若省略ORG语句，则从本段起始地址开始连续存放。偏移地址的范围为(0x0000=0xffff)

   在大多数情况下，不需要用ORG语句设置位置指针。由于段定义语句是段的起点，它的偏移地址为0000H，以后每分配一个字节，位置指针自动加1，所以每条指令都有确定的偏移地址。只有程序要求改变这个位置指针时，才需要安排ORG语句。通常ORG语句可以出现在程序中任何位置上。

   使用org 07c00h是因为

   1) 首先DS是默认为0的

   2）引导扇区会被加载在07c00h处，也就是磁盘中的代码和内存的代码有一个偏移量为07c00h

   当我们设置了org之后，后面的偏移都会默认在0x7c00的基础上。也就是说，如果不加org的话，我们在代码中指定指令时就必须制定 偏移 + 07c00h 来达到相同的效果了。

2. ; 注释

   > ; 后的文字作为注释

3. [] 地址

   > [立即数]
   >
   > > [存储器]
   > > [存储器 + 立即数]

    任何不被[]包含的变量都是地址。[]表示一个内存单元。内存单元的段地址为ds中的存储数据，偏移地址为[]里面表示的数据。

4. $ 当前行位置

   > $表示当前行的地址

    在汇编程序对源程序进行汇编的过程中，使用地址计数器来保证当前正在汇编的指令地址。地址计数器值可用“$”来表示，汇编语言也允许用户直接用“$”来引用地址计数器的当前值，因此，ORG $＋5可表示从当前地址开始跳过5个字节存储单元，在指令和伪指令中，也可直接用“$”表示地址计数器的当前值。

     故jmp $进入了一个无限循环。

5. `$$`  当前段开始位置  

   > $ 代表当前段的开始地址

6. EQU 定义常量

   > one equ 1  使用one常量代表1

7. DB, DW,DD 输出(1个字节，2个字节，4个字节)

   > 说明：

   > DB 写出一个字节（BYTE）。会按照字节输出

   > DW 输出一个字(WORD=2BYTE).也就是输出2个字节(16位)。

   > DD 输出两个字(DoubleWord=4BYTE).也就是输出4个字节(32位)

8. RESB, RESW, RESD 填充(1个字节，2个字节，4个字节)

   > 说明：

   > RESB 510-($-$$)    意思即是510字节位置（0x1fe） 减去这一行现在的字节位置:132。这些都填入0x00

   > $表示当前行被汇编后的地址，也就是当前行的地址。$$代表一个section节的开始地址。也就是这个section的开始地址。

   > 也可以使用times 510-($-$$)  db  0来表示上面的意思。

9. times 重复指令或数据

   > 说明：

   > times 510-($-$$) DB 0 前缀引起指令被汇编多次。其中$$表示是该程序的初始代码段的地址，故`DB 0`该指令将会被执行510-($-$$)次。也就是用0来填充剩下的空间，达到510字节。

